# -*- coding: utf-8 -*-
"""classify_from_features.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/zhaoq23/RealOrAI-DogDetector/blob/main/classify_from_features.ipynb
"""

# STEP 0: Setup for Google Colab
!pip install ipywidgets --quiet

# ‚úÖ NEW: Clone your GitHub repo and navigate into it
import os, sys, shutil

# Remove old copy if it exists
if os.path.exists("RealOrAI-DogDetector"):
    shutil.rmtree("RealOrAI-DogDetector")

!git clone https://github.com/zhaoq23/RealOrAI-DogDetector.git

# Change directory to repo and add to Python path
os.chdir("RealOrAI-DogDetector")
sys.path.append(".")

# ‚úÖ Now your model import will work
import torch
from IPython.display import display
import ipywidgets as widgets
from models import BayesianMLP

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

!pip install ipywidgets --quiet

import torch
from torch.utils.data import DataLoader
from IPython.display import display
import ipywidgets as widgets
from models import BayesianMLP

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

def load_model(model_path="plusdiff_model.pt"):
    model = BayesianMLP()
    model.load_state_dict(torch.load(model_path, map_location=device))
    model.eval()
    return model

def classify_feature_tensor(tensor, model):
    tensor = tensor.to(device)
    with torch.no_grad():
        output = model(tensor)
        probs = torch.sigmoid(output).squeeze()

        # If only one item, make it iterable
        if probs.dim() == 0:
            probs = probs.unsqueeze(0)

        for i, p in enumerate(probs):
            label = "AI-GENERATED ü§ñ" if p >= 0.5 else "REAL üê∂"
            print(f"Image {i+1}: {label}  |  Probability: {p:.2f}")

upload = widgets.FileUpload(accept='.pt', multiple=False)

def on_upload_change(change):
    if upload.value:
        file_info = next(iter(upload.value.values()))
        with open("temp.pt", "wb") as f:
            f.write(file_info['content'])

        # Load the .pt file and extract features
        data = torch.load("temp.pt")
        if isinstance(data, tuple):  # (features, label)
            tensor = data[0]
        else:
            tensor = data

        if len(tensor.shape) == 1:
            tensor = tensor.unsqueeze(0)  # Add batch dimension if needed

        # ‚úÖ Add this padding fix
        if tensor.shape[1] == 384:
            padding = torch.zeros((tensor.shape[0], 1))
            tensor = torch.cat([tensor, padding], dim=1)

        # Load model and classify
        model = load_model()
        classify_feature_tensor(tensor, model)

upload.observe(on_upload_change, names='value')
display(upload)